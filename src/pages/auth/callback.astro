---
import { createSupabaseClient } from '@/lib/supabase';
import type { ProfileInsert } from '@/lib/database.types';

const { url } = Astro;
const requestUrl = new URL(url);
const code = requestUrl.searchParams.get('code');
const error = requestUrl.searchParams.get('error');
const error_description = requestUrl.searchParams.get('error_description');
const next = requestUrl.searchParams.get('next') ?? '/dashboard';

// Handle errors from Supabase
if (error) {
  console.error('Auth callback error:', error, error_description);
  return Astro.redirect(`/auth/login?error=${error}`);
}

// Handle the authorization code flow
if (code) {
  const supabase = createSupabaseClient(Astro);
  const { error: sessionError } = await supabase.auth.exchangeCodeForSession(code);
  
  if (!sessionError) {
    // Check if user exists and create/update profile if needed
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user) {
      // Check if profile exists
      const { data: existingProfile } = await supabase
        .from('profiles')
        .select('id')
        .eq('id', user.id)
        .single();
      
      // If no profile exists, create one
      if (!existingProfile) {
        const profileData: ProfileInsert = {
          id: user.id,
          email: user.email || '',
          full_name: user.user_metadata?.full_name || '',
          phone: user.user_metadata?.phone || null,
          role: user.user_metadata?.role || 'user',
          status: 'active',
          email_verified: user.email_confirmed_at ? true : false,
          phone_verified: false,
        };
        
        const { error: profileError } = await supabase
          .from('profiles')
          .insert(profileData);
        
        if (profileError) {
          console.error('Error creating profile:', profileError);
        }
      }
    }
    
    return Astro.redirect(next);
  } else {
    console.error('Session exchange error:', sessionError);
  }
}

// If there's no code and no error, check if this is a fragment-based callback
// (This happens with email confirmations)
// We'll handle this client-side
---

<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Procesando autenticación...</title>
</head>
<body>
  <div style="display: flex; justify-content: center; align-items: center; min-height: 100vh; font-family: system-ui;">
    <div style="text-align: center;">
      <h2>Procesando autenticación...</h2>
      <p>Por favor espera mientras te redirigimos.</p>
    </div>
  </div>
  
  <script>
    // Handle fragment-based authentication (email confirmation flow)
    if (window.location.hash && window.location.hash.includes('access_token')) {
      // Parse the fragment
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const accessToken = hashParams.get('access_token');
      const refreshToken = hashParams.get('refresh_token');
      
      if (accessToken && refreshToken) {
        // Store the session and redirect
        // We need to make a request to our server to handle this properly
        fetch('/api/auth/callback', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            access_token: accessToken,
            refresh_token: refreshToken,
          }),
        }).then(response => {
          if (response.ok) {
            window.location.href = '/dashboard';
          } else {
            window.location.href = '/auth/login?error=auth_callback_error';
          }
        }).catch(() => {
          window.location.href = '/auth/login?error=auth_callback_error';
        });
      } else {
        window.location.href = '/auth/login?error=auth_callback_error';
      }
    } else if (!window.location.search.includes('code')) {
      // No code, no fragment, redirect to login
      window.location.href = '/auth/login?error=auth_callback_error';
    }
  </script>
</body>
</html>